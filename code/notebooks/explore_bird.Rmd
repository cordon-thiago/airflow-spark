---
title: "explore_bird"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(DBI)
library(dygraphs)
library(xts)
library(rmarkdown)
library(dplyr)
library(ggplot2)

# Connect to "jdbc:postgresql://postgres:5432/test"
con <- DBI::dbConnect(
  drv = RPostgres::Postgres(),
  host = "postgres",
  port=5432,
  dbname = "test",
  user = "test",
  password = "postgres"
  )


df_to_ts <- function(df){
  xts(
    x = df[,2:ncol(df)],
    order.by = df[,1]
    )
}

gen_dygraph <- function(df){
  dygraph(df_to_ts(df)) %>% 
  dyRangeSelector() %>% 
  dyOptions(connectSeparatedPoints=TRUE)
}

```

From the ingestion of 100 P4 data. All them are from `ENECO`, and all of them have `product = E` and `deleted = false` (but this is just a )

The [documentation file](https://drive.google.com/file/d/1BJNajFnqoHzoiX_q6GPDrbKfv_eIJncS/view?usp=sharing) demonstrated to be very useful.

## Summary of questions:

- Data is not unique by `measurement_timestamp, ean_code, product, channel, collector`. The same data with the same timestamp is collected several times, which forces the question "which one is the valid?" Taking the last measured data `event_timestamp` seems a right default, but what has business to say about this?

- There are many gaps in the data. How to treat them?

- Is the relation between `ean_code` and `customer_id` one-to-one?

- What do we do with the different `collector`, some of which have almost no data?

- Why does EDT do not correspond to the sum of ED1 and ED2?

## General exploration

Head of `bird_historical_meter_raw`
```{sql connection=con, output.var="init"}
select * 
from bird_historical_meter_raw
limit 10
```
```{r echo=FALSE}
paged_table(init)
```

More than one file per ean_code (50 ean code, 100 ingested files)
```{sql connection=con}
select count(distinct ean_code)
from bird_historical_meter_raw
```

One `ean_code`
```{sql connection=con, output.var="one_ean_code"}
select measurement_timestamp, measurement_value, product, collector, channel
from bird_historical_meter_raw
where ean_code = '0005986cdabab9f301'
```

How the metrics look for one `ean_code`:
```{r}
one_ean_code %>% 
  ggplot(aes(x = measurement_timestamp, y = measurement_value, color = channel)) + 
  geom_line() +
  facet_grid(collector ~ product)
```

This advances some of the problems observed in the data:

- Repeated data (what is the right measurement for a timestamp?)

- Several `collector` per `ean_code`, some of which have almost no data

- EDT (total?) does not need to correspond to the sum of the other two channels (ED1 and ED2)


## Channels

Seven different channels
```{sql connection=con}
select channel, count(*)
from bird_historical_meter_raw
group by channel
```

Channels per ean connection range between 2 and 7
```{sql connection=con, output.var="channels_per_ean"}
select ean_code, count(distinct channel) as n_channel
from bird_historical_meter_raw
group by ean_code
order by n_channel desc
```
```{r echo=FALSE}
paged_table(channels_per_ean)
```

`customer_id` and `ean_code` seem to have a 1-1 relation? What if another customer moves in this address, would the `customer_id` change but retain the `ean_code`?
```{sql connection=con}
select distinct X.n_customer
from (
	select ean_code, count(distinct customer_id) as n_customer
	from bird_historical_meter_raw
	group by ean_code
	order by n_customer desc
) X
```

## Hunting for uniqueness

`measurement_timestamp, ean_code, product, collector, channel` does not provide uniqueness
```{sql connection=con, output.var="searching_uniqueness"}
select measurement_timestamp, ean_code, product, collector, channel, count(*) as instances
from bird_historical_meter_raw
group by measurement_timestamp, ean_code, product, collector, channel
order by instances desc
limit 10
```
```{r echo=FALSE}
paged_table(searching_uniqueness)
```

In some cases, there are more than 10 rows that look exactly the same except for the `event_timestamp`:
```{sql connection=con, output.var="not_unique_instances"}
select * 
from bird_historical_meter_raw 
where measurement_timestamp = '2021-10-04 02:00:00.000 +0200'
and collector = 'PRODUCED_ELECTRICITY'
and channel = 'PET'
and ean_code = '00b0ece7917da1339a'
order by event_timestamp
```
```{r echo=FALSE}
paged_table(not_unique_instances)
```
How does this look like?
```{sql connection=con, output.var='ts_not_unique'}
select * 
from bird_historical_meter_raw 
where collector = 'PRODUCED_ELECTRICITY'
and channel = 'PET'
and ean_code = '00b0ece7917da1339a'
order by event_timestamp
```
```{r}
ts_not_unique %>% 
  select(measurement_timestamp, measurement_value) %>% 
  gen_dygraph()
```

This shows that collector `PRODUCED_ELECTRICITY` is different from the other metrics, that are eminently cumulative

How do repeated data look like in other collector? a contrived example I found:
```{sql connection=con, output.var='serrated'}
select *
from bird_historical_meter_raw
where channel = 'EDT'
and ean_code = '00b3a0a7fcf068fd89'
and measurement_timestamp < '2020-01-01'
and collector = 'INTERPOLATED'
order by event_timestamp
```

```{r}
ggplot(serrated, aes(x=measurement_timestamp, y=measurement_value)) + 
  geom_point()
```

There are at least 3 different "timelines" measured simultaneously

```{r}
ggplot(serrated, aes(x=measurement_timestamp, y=measurement_value, color = as.factor(event_timestamp))) + 
  geom_point()

```
The non-uniqueness is explained by the different retrieval times (`event_timestamp`). It seems that we could select the most recent point in each observation and in that way obtain an uniform line:

```{sql connection=con, output.var='serrated2'}
select measurement_timestamp,
  last(measurement_value, event_timestamp) as measurement_value,
  'pick_last' as method
from bird_historical_meter_raw
where channel = 'EDT'
and ean_code = '00b3a0a7fcf068fd89'
and measurement_timestamp < '2020-01-01'
and collector = 'INTERPOLATED'
group by measurement_timestamp
```

```{r}
serrated %>%
  select(measurement_timestamp, measurement_value) %>% 
  mutate(method = 'pick_all') %>% 
  rbind(serrated2) %>% 
  ggplot(aes(x=measurement_timestamp, y=measurement_value, color = method)) +
  geom_point()
```
The uniform line `pick_last` has outliers that correspond to points where the most recent data is the "wrong" timeline.

## Relation product - channel

Cross join indicated that `product` and `channel` are not orthogonal at all, and have variable levels of repeated rows
```{sql connection=con, output.var="product_channel"}
select pr.collector, ch.channel, bhmr.n_rows, repeated.duplicated_rows
from (
	select distinct channel from bird_historical_meter_raw
	) ch
cross join (
	select distinct collector from bird_historical_meter_raw
	) pr
left join (
	select channel, collector, count(*) as n_rows
	from bird_historical_meter_raw
	group by collector, channel
) bhmr 
	on bhmr.channel = ch.channel 
	and bhmr.collector = pr.collector
left join(
	select X.collector, X.channel, sum(instances) - count(*) as duplicated_rows
	from (
		select measurement_timestamp, ean_code, product, collector, channel, count(*) as instances
		from bird_historical_meter_raw
		group by measurement_timestamp, ean_code, product, collector, channel
		order by instances desc
	) X
	group by collector, channel
) repeated
	on bhmr.channel = repeated.channel 
	and bhmr.collector = repeated.collector
```
```{r echo=FALSE}
paged_table(product_channel)
```

## Looking for solar (beta)

```{sql connection=con}
with ean_with_solar as (
	select ean_code
	from (
		select * 
		from bird_historical_meter_raw
		where channel = 'ERT'
	) X
	group by ean_code
	having max(measurement_value) - min(measurement_value) > 0
)

select * from ean_with_solar

```

