---
title: "explore_postgres_r"
output: html_document
---

# R

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(DBI)
```


```{r}
# Connect to "jdbc:postgresql://postgres:5432/test"
con <- DBI::dbConnect(
  drv = RPostgres::Postgres(),
  host = "postgres",
  port=5432,
  dbname = "test",
  user = "test",
  password = "postgres"
  )
```

Some experimentation
```{r}
dbListTables(con)
dbWriteTable(con, "mtcars", mtcars)
dbListTables(con)

dbListFields(con, "mtcars")
dbReadTable(con, "mtcars")

# You can fetch all results:
res <- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(res)
dbClearResult(res)

# Or a chunk at a time
res <- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
while(!dbHasCompleted(res)){
  chunk <- dbFetch(res, n = 5)
  print(nrow(chunk))
}
# Clear the result
dbClearResult(res)

# Disconnect from the database
dbDisconnect(con)
```

```{r}
dbGetQuery(conn = con, "select * from mtcars limit 10")
```

```{sql connection=con}
TRUNCATE TABLE whale_historical_ptu
```

```{sql connection=con}
SELECT * FROM whale_historical_ptu
LIMIT 10
```

```{sql connection=con, output.var="foo_ts"}
select 
datetime, 
consumption
from whale_historical_ptu
where connection_id = '871685900000000608MV'
and consumption is not null
```

```{r}
library(ggplot2)

ggplot(foo_ts, aes(x = datetime, y = consumption)) + geom_line()

```


```{sql connection=con}
SELECT drat, wt AS foo
FROM mtcars
WHERE carb = 1
```

```{sql connection=con}

select
connection_id,
min(datetime) as dttm_from,
max(datetime) as dttm_until,
(max(datetime) - min(datetime)) as dttm_range
FROM (
	select *
	from whale_historical_ptu
	where consumption is not null 
) as cons
group by connection_id
order by dttm_range desc


select connection_id, count(*)
from whale_historical_ptu
where consumption > 0
group by connection_id

select connection_id, datetime , consumption 
from whale_historical_ptu
where consumption > 0
order by connection_id, datetime desc 

select positive.* from (
	select connection_id, datetime , consumption 
	from whale_historical_ptu
	where consumption > 0
	) as positive
order by datetime desc limit 1

group by positive.connection_id 


select 
whp.datetime, 
whp.consumption,
kwh.temperature,
kwh.solar_radiation
from whale_historical_ptu whp
left join knmi_weather_hour kwh 
on whp.datetime = kwh.datetime 
where whp.connection_id = '871685900000000608MV'
order by whp.datetime


select *
from whale_historical_ptu whp
left join knmi_weather_hour kwh 
on whp.datetime = kwh.datetime 
where whp.connection_id = '871685900000000608MV'
order by datetime

analyze whale_historical_ptu

create index on whale_historical_ptu (datetime);


select *
from whale_historical_ptu whp
left join knmi_weather_hour kwh 
on whp.datetime = kwh.datetime 
where whp.connection_id = '871685900000000608MV'
limit 10

select * 
from knmi_weather_hour kwh 
limit 10

select 
datetime, 
consumption
from whale_historical_ptu
where connection_id = '871685900000000608MV'
and consumption is not null



```

```{sql connection=conn}
-- find users with any positive meter readings
with positives AS(
	SELECT DISTINCT ON (connection_id)
	       connection_id,
	       datetime as earliest_positive
	FROM   (
		select * 
		from whale_historical_ptu 
		ORDER  BY datetime desc
	) X
	where consumption > 0
), joined as (
	select 
		distinct whp.connection_id,
		positives.earliest_positive
	from whale_historical_ptu whp
	left join positives on whp.connection_id = positives.connection_id
)

select 
	connection_id,
	case when joined.earliest_positive is null then 'FALSE' else 'TRUE' end as has_solar,
	earliest_positive as label_from
from joined

```



# Python
